/*
auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect } from 'react'
import { useFrame } from 'react-three-fiber'
import { useGLTF } from '@react-three/drei/useGLTF'

import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader'
import {AnimationMixer, Bone, Mesh, MeshPhongMaterial, SkinnedMesh} from "three";
import {hexStringToCode} from "../../../utils/color";

type GLTFResult = GLTF & {
  nodes: {
    Face: Mesh
    ['Shoulder.L_1']: Mesh
    Warrior_Sword: Mesh
    ['Shoulder.R_1']: Mesh
    Warrior002: SkinnedMesh
    Root: Bone
  }
}

type ActionName =
  | 'Death'
  | 'Idle'
  | 'Idle_Weapon'
  | 'PickUp'
  | 'Punch'
  | 'RecieveHit'
  | 'RecieveHit_Attacking'
  | 'Run'
  | 'Sword_Attack'
  | 'Walk'
type GLTFActions = Record<ActionName, THREE.AnimationAction>

const lightOrangeIndividualMaterial = new MeshPhongMaterial({
  color: hexStringToCode("#393939"),
  skinning: true,
});
lightOrangeIndividualMaterial.color.convertSRGBToLinear();

export default function Warrior({moving, ...props}: JSX.IntrinsicElements['group'] & {
  moving: boolean,
}) {
  const group = useRef<THREE.Group>()
  const { nodes, animations } = useGLTF('/Warrior.glb') as GLTFResult
  const currentAnimationRef = useRef<any>()
  const actions = useRef<GLTFActions>()
  const [mixer] = useState(() => new AnimationMixer(nodes.Warrior002))
  useFrame((state, delta) => mixer.update(delta))
  useEffect(() => {
    actions.current = {
      Death: mixer.clipAction(animations[0], group.current),
      Idle: mixer.clipAction(animations[1], group.current),
      Idle_Weapon: mixer.clipAction(animations[2], group.current),
      PickUp: mixer.clipAction(animations[3], group.current),
      Punch: mixer.clipAction(animations[4], group.current),
      RecieveHit: mixer.clipAction(animations[5], group.current),
      RecieveHit_Attacking: mixer.clipAction(animations[6], group.current),
      Run: mixer.clipAction(animations[7], group.current),
      Sword_Attack: mixer.clipAction(animations[8], group.current),
      Walk: mixer.clipAction(animations[9], group.current),
    }
    return () => animations.forEach((clip) => mixer.uncacheClip(clip))
  }, [])
  useEffect(() => {

    if (!actions.current) return

    const duration = 0.25
    const currentAnimation: any = currentAnimationRef.current

    let newAnimation = actions.current.Idle

    if (moving) {
      newAnimation = actions.current.Walk
    }

    if (currentAnimation && currentAnimation !== newAnimation)  {
      currentAnimation.fadeOut(duration)
      newAnimation
          .reset()
          .setEffectiveTimeScale(1)
          .setEffectiveWeight(1)
          .fadeIn(duration)
          .play();
    } else {
      newAnimation.play();
    }

    currentAnimationRef.current = newAnimation

  }, [moving])
  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={nodes.Root} />
      <skinnedMesh
        material={lightOrangeIndividualMaterial}
        geometry={nodes.Warrior002.geometry}
        skeleton={nodes.Warrior002.skeleton}
        castShadow
        receiveShadow
      />
    </group>
  )
}

useGLTF.preload('/Warrior.glb')
