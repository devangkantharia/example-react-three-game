/*
auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect } from 'react'
import { useFrame } from 'react-three-fiber'
import { useGLTF } from '@react-three/drei/useGLTF'

import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader'
import {AnimationAction, AnimationMixer, Bone, Group, LoopOnce, MeshToonMaterial, SkinnedMesh} from "three";
import {hexStringToCode} from "../../../utils/color";

type GLTFResult = GLTF & {
  nodes: {
    Cube004: SkinnedMesh
    ['Cube.004_1']: SkinnedMesh
    ['Cube.004_2']: SkinnedMesh
    ['Cube.004_3']: SkinnedMesh
    ['Cube.004_4']: SkinnedMesh
    Bone: Bone
  }
  materials: {
    Armor: THREE.MeshStandardMaterial
    Armor_Dark: THREE.MeshStandardMaterial
    Skin: THREE.MeshStandardMaterial
    Detail: THREE.MeshStandardMaterial
    Red: THREE.MeshStandardMaterial
  }
}

const redMaterial = new MeshToonMaterial({
    color: hexStringToCode("#45555a"),
    skinning: true,
});
redMaterial.color.convertSRGBToLinear();

const detailMaterial = new MeshToonMaterial({
    color: hexStringToCode("#ffffff"),
    skinning: true,
});
detailMaterial.color.convertSRGBToLinear();

const skinMaterial = new MeshToonMaterial({
    color: hexStringToCode("#131313"),
    skinning: true,
});
skinMaterial.color.convertSRGBToLinear();

const armorMaterial = new MeshToonMaterial({
    color: hexStringToCode("#393939"),
    skinning: true,
});
armorMaterial.color.convertSRGBToLinear();

const armorDarkMaterial = new MeshToonMaterial({
    color: hexStringToCode("#242424"),
    skinning: true,
});
armorDarkMaterial.color.convertSRGBToLinear();

type ActionName = 'Idle' | 'PickUp' | 'Punch' | 'RecieveHit' | 'Run' | 'SitDown' | 'Walk'
type GLTFActions = Record<ActionName, AnimationAction>

export default function Knight({moving, running, lastAttack, ...props}: JSX.IntrinsicElements['group'] & {
    moving: boolean,
    running: boolean,
    lastAttack: number,
}) {
  const group = useRef<Group>()
  const { nodes, materials, animations } = useGLTF('/Knight_Golden_Male.glb') as GLTFResult

  const actions = useRef<GLTFActions>()
  const [mixer] = useState(() => new AnimationMixer(nodes['Cube.004_4']))

    const currentAnimationRef = useRef<any>()

  useFrame((state, delta) => mixer.update(delta))
  useEffect(() => {
    actions.current = {
      Idle: mixer.clipAction(animations[0], group.current),
      PickUp: mixer.clipAction(animations[1], group.current),
      Punch: mixer.clipAction(animations[2], group.current),
      RecieveHit: mixer.clipAction(animations[3], group.current),
      Run: mixer.clipAction(animations[4], group.current),
      SitDown: mixer.clipAction(animations[5], group.current),
      Walk: mixer.clipAction(animations[6], group.current),
    }
    actions.current.Punch.loop = LoopOnce
    actions.current.Punch.clampWhenFinished = true
    actions.current.Punch.timeScale = 1.2
    return () => animations.forEach((clip) => mixer.uncacheClip(clip))
  }, [])

    useEffect(() => {

        if (!actions.current) return

        const duration = 0.25
        const currentAnimation: any = currentAnimationRef.current

        let newAnimation = actions.current.Idle
        let nonAttackAnimation = newAnimation

        if (moving) {
            if (running) {
                newAnimation = actions.current.Run
            } else {
                newAnimation = actions.current.Walk
            }
        }

        if (lastAttack && lastAttack > Date.now() - 500) {
            nonAttackAnimation = newAnimation
            newAnimation = actions.current.Punch
        }

        if (currentAnimation && currentAnimation !== newAnimation)  {
            currentAnimation.fadeOut(duration)
            newAnimation
                .reset()
                .setEffectiveWeight(1)
                .fadeIn(duration)
                .play();
        } else if (currentAnimation === newAnimation && newAnimation === actions.current.Punch) {
            newAnimation.reset()
                .play()
        } else {
            newAnimation.play();
        }

        currentAnimationRef.current = newAnimation

        const onFinished = () => {
            currentAnimationRef.current.fadeOut(duration)
            nonAttackAnimation
                .reset()
                .setEffectiveWeight(1)
                .fadeIn(duration)
                .play();
            currentAnimationRef.current = nonAttackAnimation
        }

        mixer.addEventListener('finished', onFinished)

        return () => {
            mixer.removeEventListener('finished', onFinished)
        }

    }, [moving, running, lastAttack])

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={nodes.Bone} />
      <skinnedMesh receiveShadow castShadow material={armorMaterial} geometry={nodes.Cube004.geometry} skeleton={nodes.Cube004.skeleton} />
      <skinnedMesh receiveShadow castShadow
        material={armorDarkMaterial}
        geometry={nodes['Cube.004_1'].geometry}
        skeleton={nodes['Cube.004_1'].skeleton}
      />
      <skinnedMesh receiveShadow castShadow
        material={armorDarkMaterial}
        geometry={nodes['Cube.004_2'].geometry}
        skeleton={nodes['Cube.004_2'].skeleton}
      />
      <skinnedMesh receiveShadow castShadow
        material={armorMaterial}
        geometry={nodes['Cube.004_3'].geometry}
        skeleton={nodes['Cube.004_3'].skeleton}
      />
      <skinnedMesh receiveShadow castShadow
        material={armorDarkMaterial}
        geometry={nodes['Cube.004_4'].geometry}
        skeleton={nodes['Cube.004_4'].skeleton}
      />
    </group>
  )
}

useGLTF.preload('/Knight_Golden_Male.glb')
